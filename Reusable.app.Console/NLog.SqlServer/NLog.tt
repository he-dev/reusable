<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="$(ProjectDir)\$(OutDir)\Reusable.Utilities.SqlClient.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.SqlClient" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Reusable.Utilities.SqlClient" #>
<#@ import namespace="Reusable.Utilities.SqlClient.SqlSchemas" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Globalization" #>
<#@ output extension=".config" #>
<?xml version="1.0" encoding="utf-8" ?>
<#
	
	// --- SETTINGS ---
	var connectionString = "data source=(local);initial catalog=TestDb;Integrated Security=true;";
	//var database = "testingdb";
	var schema = "dbo";
	var tablePattern = "Test_SemLog3$";
	var fallbackLogPattern = "Test_SemLog3$";
	var internalLogFile = @"c:\temp\Reusable.Apps.Server.N.log";
	
#>
<#

	// --- DEFAULTS ---
	
	var indexColumns = new [] { "Id" };
	var layouts  = new Dictionary<string, string>
	{
		["Timestamp"] = "${longdate:universalTime=true}",
		//["Environment"] = "${environmentLayout}",
		["Logger"] = "${logger}",
		//["Logger"] = "${smart-properties:key=DisplayLogger:ignoreCase=true}",
		["Level"] = "${level:lowercase=true}",
		//["ElapsedMilliseconds"] = "${event-properties:item=ElapsedMilliseconds}",
		["Exception"] = "${onexception:${exceptionLayout}}",
	};
	var indentWidth = 3;
	var idColumn = "Id";
#>
<nlog
  xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  internalLogFile="<#=internalLogFile#>"
  internalLogLevel="Error">

  <!-- *** This file was autogenerated on <#= DateTime.UtcNow.ToString(CultureInfo.InvariantCulture) #> (UTC) *** -->
  <!-- *** Any modifications can be lost. *** -->

  <!-- sub-templates -->

  <variable name="environmentNotAvailable" value="N/A" />
  <variable name="environmentLayout" value="${whenEmpty:whenEmpty=${environmentNotAvailable}:inner=${event-context:item=Environment}}" />

  <variable name="callsiteLayout" value="${callsite:className=true:fileName=true:methodName:true}" />
  <variable name="exceptionLayout" value="${exception:format=tostring:separator= | :innerFormat=tostring,message:maxInnerExceptionLevel=7:innerExceptionSeparator= | }" />
  <variable name="stackTraceLayout" value="${stacktrace:format=raw:topFrames=7:separator= » }" />

  <!-- full templates -->  

  <variable name="debuggerLayout" value="OmniLog » ${level:uppercase=true} | ${message}${onexception:${newline}${exceptionLayout}}" />

  <#
	//var sqlSchemaReader = new SqlSchemaReader();
	var tableNameMatches = new Func<SqlTableSchema, bool>(sqlTableSchema => Regex.IsMatch(sqlTableSchema.TableName, tablePattern, RegexOptions.IgnoreCase));
	var sqlTableSchemaRestriction = new SqlTableSchema
	{
		TableSchema = schema
	};
	var tables = SqlHelper.Execute(connectionString, conn =>
	{
        return
            conn
                .GetTableSchemas(sqlTableSchemaRestriction)
                .Where(tableNameMatches)
                .ToList();
	});
  #>
  <targets>    

    <target xsi:type="Debugger" name="debugger" layout="${debuggerLayout}" />

<#
foreach(var table in tables)
{
	var sqlColumnSchemaRestriction = new SqlColumnSchema
	{
		TableSchema = schema,
		TableName = table.TableName
	};
	var columns = SqlHelper.Execute(connectionString, conn => 
	{
		return
			conn
				.GetColumnSchemas(sqlColumnSchemaRestriction)
				.ToList();
	});

	//sqlSchemaReader.GetSqlColumnSchemas(connectionString, sqlColumnSchemaRestriction);
#>	
		<target xsi:type="Database" name="<#=table.TableName#>" dbProvider="System.Data.SqlClient" connectionString="<#=connectionString#>">
			<commandText>
				INSERT INTO [<#=schema#>].[<#=table.TableName#>] (
<#
foreach(var column in columns.Where(c => !c.ColumnName.Equals(idColumn, StringComparison.OrdinalIgnoreCase)).Select((x, i) => new { x, i }))
{
	PushIndent(CreateIndent(indentWidth, 4));
	Write("[" + column.x.ColumnName + "]");
	WriteLine(column.i < columns.Count - 2 ? "," : string.Empty);
	PopIndent();
}
#>
				) VALUES (
<#
foreach(var column in columns.Where(c => !c.ColumnName.Equals(idColumn, StringComparison.OrdinalIgnoreCase)).Select((x, i) => new { x, i }))
{
	PushIndent(CreateIndent(indentWidth, 4));
	Write(column.x.IsNullable == "YES" ? "NULLIF(@" + column.x.ColumnName + ", '')" : "@" +  column.x.ColumnName);	
	WriteLine(column.i < columns.Count - 2 ? "," : string.Empty);
	PopIndent();
}
#>
				)
			</commandText>
						
<#

var nonIndexColumns = columns.Where(column => !indexColumns.Contains(column.ColumnName, StringComparer.OrdinalIgnoreCase));

foreach(var column in nonIndexColumns)
{
	if (layouts.TryGetValue(column.ColumnName, out var layout))
	{
#>
			<parameter name="@<#=column.ColumnName#>" layout="<#=layout#>" />
<#
	}
	else
	{
#>
			<parameter name="@<#=column.ColumnName#>" layout="${smart-properties:key=<#=column.ColumnName#>:ignoreCase=true}" />
<#
	}
}
#>
		</target>
<#
	}
#>

  </targets>

  <rules>

    <!-- Log everything to debugger -->
    <logger name="*" minlevel="Trace" writeTo="debugger" enabled="true" final="false" />

<#
foreach(var table in tables)//.Where(t => !Regex.IsMatch(t.TableName, fallbackLogPattern, RegexOptions.IgnoreCase)))
{
#>
    <logger name="<#=table.TableName#>" appendTo="<#=table.TableName#>" minlevel="Trace" enabled="true" final="true" />
<#
}
#>   
<#
var fallbackLog = tables.SingleOrDefault(t => Regex.IsMatch(t.TableName, fallbackLogPattern, RegexOptions.IgnoreCase));
if (fallbackLog != null)
{
#>
    <!-- Use the fallbackLog if no other log matches. -->
    <logger name="*" appendTo="<#=fallbackLog.TableName#>" minlevel="Trace" enabled="true" final="true" />
<#
}
#>

  </rules>
</nlog>

<#+
private string CreateIndent(int width, int depth)
{
	return new string(' ', width * depth);
}
#>